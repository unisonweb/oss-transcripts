ability abilities.Auth session where
  requireSession : {abilities.Auth session} session
  getSession : {abilities.Auth session} (Optional session)

type anonymous.Config
  = { hmacKey : HMACKey, useSecureCookies : Boolean }

type anonymous.UserId
  = UserId Text

type oauth2.config.AuthConfig g idToken session
  = { uriFromPath : Path ->{Route, Exception} URI,
      kickoffOAuthLoginPath : Path,
      loginPagePath : Path,
      logoutPagePath : Path,
      redirectHandlerPath : Path,
      oauth2Client : Oauth2Client idToken,
      oauth2Scopes : Optional Text,
      successCallback : TokenResponse idToken ->{g, Route, Exception} session,
      validateSession : '{g, Route} Optional session,
      saveSession : session ->{g, Route} (),
      removeSession : session ->{g, Route} (),
      useSecureCookies : Boolean }

type oauth2.internal.Base64UrlUnpadded format
  = Base64UrlUnpadded format

type oauth2.internal.State
  = { continueTo : Optional URI, stateId : Text }

type oauth2.routes.internal.BadRequest
  = BadRequest Text

type utils.hmac.HMACKey
  = HMACKey Bytes

abilities.Auth.doc : Doc
abilities.Auth.doc =
  {{
  * {getSession} will fetch the current user's authenticated session if they
    are logged in.
  * {requireSession} will fetch the current user's authenticated session if
    they are logged in, or short-circuit the action and trigger the
    authentication flow if they are not.
  }}

anonymous.Config.doc : Doc
anonymous.Config.doc =
  {{
  Required configuration for the {{
  docLink (docEmbedTermLink do anonymous.handler) }}

  * `hmacKey`: The key to use when signing cookies via HMAC.
  * `useSecureCookies` indicates whether to set the `Secure` flag on cookies
    used in auth. This should always be set to `true` for production
    applications, but it's sometimes useful to disable this when working on
    localhost where `https` may not be supported.
  }}

anonymous.Config.hmacKey : anonymous.Config -> HMACKey
anonymous.Config.hmacKey = cases anonymous.Config.Config hmacKey _ -> hmacKey

anonymous.Config.hmacKey.modify :
  (HMACKey ->{g} HMACKey) -> anonymous.Config ->{g} anonymous.Config
anonymous.Config.hmacKey.modify f = cases
  anonymous.Config.Config hmacKey useSecureCookies ->
    anonymous.Config.Config (f hmacKey) useSecureCookies

anonymous.Config.hmacKey.set : HMACKey -> anonymous.Config -> anonymous.Config
anonymous.Config.hmacKey.set hmacKey1 = cases
  anonymous.Config.Config _ useSecureCookies ->
    anonymous.Config.Config hmacKey1 useSecureCookies

anonymous.Config.useSecureCookies : anonymous.Config -> Boolean
anonymous.Config.useSecureCookies = cases
  anonymous.Config.Config _ useSecureCookies -> useSecureCookies

anonymous.Config.useSecureCookies.modify :
  (Boolean ->{g} Boolean) -> anonymous.Config ->{g} anonymous.Config
anonymous.Config.useSecureCookies.modify f = cases
  anonymous.Config.Config hmacKey useSecureCookies ->
    anonymous.Config.Config hmacKey (f useSecureCookies)

anonymous.Config.useSecureCookies.set :
  Boolean -> anonymous.Config -> anonymous.Config
anonymous.Config.useSecureCookies.set useSecureCookies1 = cases
  anonymous.Config.Config hmacKey _ ->
    anonymous.Config.Config hmacKey useSecureCookies1

anonymous.example.main : '{IO, Exception} ()
anonymous.example.main =
  do
    _ =
      """
      The secret key used to sign session cookies in our app. Make sure to change
      this to your own cryptographically secure secret of a sufficient length.
      """
    hmacKey = HMACKey (getEnv "HMAC_KEY" |> Text.toUtf8)
    _ =
      """
      If you're running your app on localhost for testing you may wish to disable secure cookies so that the app works without https.
      When running in production, always set `useSecureCookies = true`
      """
    useSecureCookies = true
    config : anonymous.Config
    config = anonymous.Config.Config hmacKey useSecureCookies
    stop =
      serveSimple
        (appRoutes |> delay (anonymous.handler config) |> delay Random.run)
        8080
    printLine "Starting server on http://localhost:8080"
    base.abilities.forever do sleep Duration.day
    stop()

anonymous.handler :
  anonymous.Config -> '{g, Auth UserId} a ->{g, Route, Exception, Random} a
anonymous.handler config app =
  use Duration *
  use Optional None toAbort
  sessionCookieName = "session"
  httpOnlyCookies = true
  _ = "Most browsers will limit the expiry, e.g. Chrome limits it to 400 days"
  sessionTTL = +1000 * Duration.day
  existingUserId : Optional UserId
  existingUserId = toOptional! do
    abortOnException do
      cookie = toAbort (getCookie sessionCookieName)
      sessionBytes = toAbort (verifyBundle (hmacKey config) cookie)
      UserId (fromUtf8 sessionBytes)
  go : Optional UserId -> Request {Auth UserId} a -> a
  go maybeUserId = cases
    { r } -> r
    { getSession -> resume } -> handle resume maybeUserId with go maybeUserId
    { requireSession -> resume } ->
      match maybeUserId with
        None ->
          newUserIdText = v4.new.asText()
          newUserId = UserId newUserIdText
          sessionBytes = Text.toUtf8 newUserIdText
          signedSession = signBundle (hmacKey config) sessionBytes
          sessionCookie =
            Cookie
              sessionCookieName
              signedSession
              None
              (Some sessionTTL)
              None
              (Some (Path []))
              (Config.useSecureCookies config)
              httpOnlyCookies
              (Some Lax)
          setCookie sessionCookie
          handle resume newUserId with go (Some newUserId)
        Some userId -> handle resume userId with go maybeUserId
  handle app() with go existingUserId

anonymous.handler.doc : Doc
anonymous.handler.doc =
  {{
  This provides quick and easy anonymous sessions for very simple apps where
  you want to store some state associated with the user. Sessions created using
  this handler should be considered ephemeral and not long-lived. This is
  useful for toy apps, to-do lists, games, etc. but not for anything that
  requires long-term user accounts.

  When a session is required, a random user id is generated and stored in a
  signed cookie.

  This provides the following behavior:

  * The {type Auth} ability will provide the same {type UserId} for the same
    user provided they are using the same browser and haven't cleared their
    cookies.
  * Calls to {requireSession} will always succeed.
  * Each assigned {type UserId} is unique and not shared between sessions.
  * The session is stored in a signed cookie, so the user can't tamper with it.
  * If a session is cleared, there is **no way to recover it**, nor is there
    any way for anyone to authenticate under that {type UserId} again.

  # Usage

    Here's an example of how we can handle the {type Auth} ability using
    {{ docLink (docEmbedTermLink do anonymous.handler) }}. All we need is our
    app's persistent {type HMACKey} which we fetch from an environment
    variable.

    {{
    docSource
      [docSourceElement (docEmbedTermLink do anonymous.example.main) []] }}
  }}

anonymous.README : Doc
anonymous.README =
  {{
  # Anonymous Auth Handler

    {{ anonymous.handler.doc }}
  }}

anonymous.UserId.bytes : UserId -> Bytes
anonymous.UserId.bytes = cases UserId txt -> Text.toUtf8 txt

oauth2.config.AuthConfig.doc : Doc
oauth2.config.AuthConfig.doc =
  {{
  * `uriFromPath` is a function that takes a path and returns a URI. This is
    used primarily for adding the scheme and host to the login and redirect
    paths.
  * `kickoffOAuthLoginPath` is the path where the auth middleware will mount
    the route which directs a user through the OAuth2 login flow.
  * `loginPagePath` is the path where the auth handler will redirect the user
    to login if they are not authenticated. If you'd prefer to simply redirect
    the user directly into the OAuth2 flow, you can set `loginPagePath` to the
    same value as `kickoffOAuthLoginPath`, which is what the default
    configuration does.
  * `redirectHandlerPath` is the path where the auth middleware will mount the
    route which handles the OAuth2 callback. You'll need to configure the URI
    registered with your identity provider to match this path.
  * `oauth2Client` is the OAuth2 client configuration for the identity provider
    you're using.
  * `oauth2Scopes` is the string of additional scopes you may want to request
    from the identity provider. `openid` is always added to the set of provided
    scopes.
  * `successCallback` is a function that takes the token response from the
    identity provider and returns a user session value to be stored by
    `saveSession`.
  * `validateSession` is a function which may use the route context to acquire
    and validate the calling user's session. The default config fetches the
    session from a session cookie.
  * `saveSession` is a function that takes a user session value and stores it
    somewhere that it can be retrieved by `validateSession`. The default config
    stores the session in a session cookie.
  * `removeSession` is a function which takes an existing user session and
    invalidates it, perhaps by setting a header to remove a cookie, or removing
    it from a database.
  * `useSecureCookies` indicates whether to set the `Secure` flag on cookies
    used in auth. This should always be set to `true` for production
    applications, but it's sometimes useful to disable this when working on
    localhost where `https` may not be supported.
  }}

oauth2.config.AuthConfig.kickoffOAuthLoginPath :
  AuthConfig g idToken session -> Path
oauth2.config.AuthConfig.kickoffOAuthLoginPath = cases
  AuthConfig _ kickoffOAuthLoginPath _ _ _ _ _ _ _ _ _ _ ->
    kickoffOAuthLoginPath

oauth2.config.AuthConfig.kickoffOAuthLoginPath.modify :
  (Path ->{h1} Path)
  -> AuthConfig g idToken session
  ->{h1} AuthConfig {h, g} idToken session
oauth2.config.AuthConfig.kickoffOAuthLoginPath.modify f = cases
  AuthConfig
    uriFromPath
    kickoffOAuthLoginPath
    loginPagePath
    logoutPagePath
    redirectHandlerPath
    oauth2Client
    oauth2Scopes
    successCallback
    validateSession
    saveSession
    removeSession
    useSecureCookies ->
    AuthConfig
      uriFromPath
      (f kickoffOAuthLoginPath)
      loginPagePath
      logoutPagePath
      redirectHandlerPath
      oauth2Client
      oauth2Scopes
      successCallback
      validateSession
      saveSession
      removeSession
      useSecureCookies

oauth2.config.AuthConfig.kickoffOAuthLoginPath.set :
  Path -> AuthConfig g idToken session -> AuthConfig {h, g} idToken session
oauth2.config.AuthConfig.kickoffOAuthLoginPath.set kickoffOAuthLoginPath1 = cases
  AuthConfig
    uriFromPath
    _
    loginPagePath
    logoutPagePath
    redirectHandlerPath
    oauth2Client
    oauth2Scopes
    successCallback
    validateSession
    saveSession
    removeSession
    useSecureCookies ->
    AuthConfig
      uriFromPath
      kickoffOAuthLoginPath1
      loginPagePath
      logoutPagePath
      redirectHandlerPath
      oauth2Client
      oauth2Scopes
      successCallback
      validateSession
      saveSession
      removeSession
      useSecureCookies

oauth2.config.AuthConfig.loginPagePath : AuthConfig g idToken session -> Path
oauth2.config.AuthConfig.loginPagePath = cases
  AuthConfig _ _ loginPagePath _ _ _ _ _ _ _ _ _ -> loginPagePath

oauth2.config.AuthConfig.loginPagePath.modify :
  (Path ->{h1} Path)
  -> AuthConfig g idToken session
  ->{h1} AuthConfig {h, g} idToken session
oauth2.config.AuthConfig.loginPagePath.modify f = cases
  AuthConfig
    uriFromPath
    kickoffOAuthLoginPath
    loginPagePath
    logoutPagePath
    redirectHandlerPath
    oauth2Client
    oauth2Scopes
    successCallback
    validateSession
    saveSession
    removeSession
    useSecureCookies ->
    AuthConfig
      uriFromPath
      kickoffOAuthLoginPath
      (f loginPagePath)
      logoutPagePath
      redirectHandlerPath
      oauth2Client
      oauth2Scopes
      successCallback
      validateSession
      saveSession
      removeSession
      useSecureCookies

oauth2.config.AuthConfig.loginPagePath.set :
  Path -> AuthConfig g idToken session -> AuthConfig {h, g} idToken session
oauth2.config.AuthConfig.loginPagePath.set loginPagePath1 = cases
  AuthConfig
    uriFromPath
    kickoffOAuthLoginPath
    _
    logoutPagePath
    redirectHandlerPath
    oauth2Client
    oauth2Scopes
    successCallback
    validateSession
    saveSession
    removeSession
    useSecureCookies ->
    AuthConfig
      uriFromPath
      kickoffOAuthLoginPath
      loginPagePath1
      logoutPagePath
      redirectHandlerPath
      oauth2Client
      oauth2Scopes
      successCallback
      validateSession
      saveSession
      removeSession
      useSecureCookies

oauth2.config.AuthConfig.logoutPagePath : AuthConfig g idToken session -> Path
oauth2.config.AuthConfig.logoutPagePath = cases
  AuthConfig _ _ _ logoutPagePath _ _ _ _ _ _ _ _ -> logoutPagePath

oauth2.config.AuthConfig.logoutPagePath.modify :
  (Path ->{h1} Path)
  -> AuthConfig g idToken session
  ->{h1} AuthConfig {h, g} idToken session
oauth2.config.AuthConfig.logoutPagePath.modify f = cases
  AuthConfig
    uriFromPath
    kickoffOAuthLoginPath
    loginPagePath
    logoutPagePath
    redirectHandlerPath
    oauth2Client
    oauth2Scopes
    successCallback
    validateSession
    saveSession
    removeSession
    useSecureCookies ->
    AuthConfig
      uriFromPath
      kickoffOAuthLoginPath
      loginPagePath
      (f logoutPagePath)
      redirectHandlerPath
      oauth2Client
      oauth2Scopes
      successCallback
      validateSession
      saveSession
      removeSession
      useSecureCookies

oauth2.config.AuthConfig.logoutPagePath.set :
  Path -> AuthConfig g idToken session -> AuthConfig {h, g} idToken session
oauth2.config.AuthConfig.logoutPagePath.set logoutPagePath1 = cases
  AuthConfig
    uriFromPath
    kickoffOAuthLoginPath
    loginPagePath
    _
    redirectHandlerPath
    oauth2Client
    oauth2Scopes
    successCallback
    validateSession
    saveSession
    removeSession
    useSecureCookies ->
    AuthConfig
      uriFromPath
      kickoffOAuthLoginPath
      loginPagePath
      logoutPagePath1
      redirectHandlerPath
      oauth2Client
      oauth2Scopes
      successCallback
      validateSession
      saveSession
      removeSession
      useSecureCookies

oauth2.config.AuthConfig.oauth2Client :
  AuthConfig g idToken session -> Oauth2Client idToken
oauth2.config.AuthConfig.oauth2Client = cases
  AuthConfig _ _ _ _ _ oauth2Client _ _ _ _ _ _ -> oauth2Client

oauth2.config.AuthConfig.oauth2Client.modify :
  (Oauth2Client idToken ->{h1} Oauth2Client idToken)
  -> AuthConfig g idToken session
  ->{h1} AuthConfig {h, g} idToken session
oauth2.config.AuthConfig.oauth2Client.modify f = cases
  AuthConfig
    uriFromPath
    kickoffOAuthLoginPath
    loginPagePath
    logoutPagePath
    redirectHandlerPath
    oauth2Client
    oauth2Scopes
    successCallback
    validateSession
    saveSession
    removeSession
    useSecureCookies ->
    AuthConfig
      uriFromPath
      kickoffOAuthLoginPath
      loginPagePath
      logoutPagePath
      redirectHandlerPath
      (f oauth2Client)
      oauth2Scopes
      successCallback
      validateSession
      saveSession
      removeSession
      useSecureCookies

oauth2.config.AuthConfig.oauth2Client.set :
  Oauth2Client idToken
  -> AuthConfig g idToken session
  -> AuthConfig {h, g} idToken session
oauth2.config.AuthConfig.oauth2Client.set oauth2Client1 = cases
  AuthConfig
    uriFromPath
    kickoffOAuthLoginPath
    loginPagePath
    logoutPagePath
    redirectHandlerPath
    _
    oauth2Scopes
    successCallback
    validateSession
    saveSession
    removeSession
    useSecureCookies ->
    AuthConfig
      uriFromPath
      kickoffOAuthLoginPath
      loginPagePath
      logoutPagePath
      redirectHandlerPath
      oauth2Client1
      oauth2Scopes
      successCallback
      validateSession
      saveSession
      removeSession
      useSecureCookies

oauth2.config.AuthConfig.oauth2Scopes :
  AuthConfig g idToken session -> Optional Text
oauth2.config.AuthConfig.oauth2Scopes = cases
  AuthConfig _ _ _ _ _ _ oauth2Scopes _ _ _ _ _ -> oauth2Scopes

oauth2.config.AuthConfig.oauth2Scopes.modify :
  (Optional Text ->{h1} Optional Text)
  -> AuthConfig g idToken session
  ->{h1} AuthConfig {h, g} idToken session
oauth2.config.AuthConfig.oauth2Scopes.modify f = cases
  AuthConfig
    uriFromPath
    kickoffOAuthLoginPath
    loginPagePath
    logoutPagePath
    redirectHandlerPath
    oauth2Client
    oauth2Scopes
    successCallback
    validateSession
    saveSession
    removeSession
    useSecureCookies ->
    AuthConfig
      uriFromPath
      kickoffOAuthLoginPath
      loginPagePath
      logoutPagePath
      redirectHandlerPath
      oauth2Client
      (f oauth2Scopes)
      successCallback
      validateSession
      saveSession
      removeSession
      useSecureCookies

oauth2.config.AuthConfig.oauth2Scopes.set :
  Optional Text
  -> AuthConfig g idToken session
  -> AuthConfig {h, g} idToken session
oauth2.config.AuthConfig.oauth2Scopes.set oauth2Scopes1 = cases
  AuthConfig
    uriFromPath
    kickoffOAuthLoginPath
    loginPagePath
    logoutPagePath
    redirectHandlerPath
    oauth2Client
    _
    successCallback
    validateSession
    saveSession
    removeSession
    useSecureCookies ->
    AuthConfig
      uriFromPath
      kickoffOAuthLoginPath
      loginPagePath
      logoutPagePath
      redirectHandlerPath
      oauth2Client
      oauth2Scopes1
      successCallback
      validateSession
      saveSession
      removeSession
      useSecureCookies

oauth2.config.AuthConfig.redirectHandlerPath :
  AuthConfig g idToken session -> Path
oauth2.config.AuthConfig.redirectHandlerPath = cases
  AuthConfig _ _ _ _ redirectHandlerPath _ _ _ _ _ _ _ -> redirectHandlerPath

oauth2.config.AuthConfig.redirectHandlerPath.modify :
  (Path ->{h1} Path)
  -> AuthConfig g idToken session
  ->{h1} AuthConfig {h, g} idToken session
oauth2.config.AuthConfig.redirectHandlerPath.modify f = cases
  AuthConfig
    uriFromPath
    kickoffOAuthLoginPath
    loginPagePath
    logoutPagePath
    redirectHandlerPath
    oauth2Client
    oauth2Scopes
    successCallback
    validateSession
    saveSession
    removeSession
    useSecureCookies ->
    AuthConfig
      uriFromPath
      kickoffOAuthLoginPath
      loginPagePath
      logoutPagePath
      (f redirectHandlerPath)
      oauth2Client
      oauth2Scopes
      successCallback
      validateSession
      saveSession
      removeSession
      useSecureCookies

oauth2.config.AuthConfig.redirectHandlerPath.set :
  Path -> AuthConfig g idToken session -> AuthConfig {h, g} idToken session
oauth2.config.AuthConfig.redirectHandlerPath.set redirectHandlerPath1 = cases
  AuthConfig
    uriFromPath
    kickoffOAuthLoginPath
    loginPagePath
    logoutPagePath
    _
    oauth2Client
    oauth2Scopes
    successCallback
    validateSession
    saveSession
    removeSession
    useSecureCookies ->
    AuthConfig
      uriFromPath
      kickoffOAuthLoginPath
      loginPagePath
      logoutPagePath
      redirectHandlerPath1
      oauth2Client
      oauth2Scopes
      successCallback
      validateSession
      saveSession
      removeSession
      useSecureCookies

oauth2.config.AuthConfig.removeSession :
  AuthConfig g idToken session -> session ->{g, Route} ()
oauth2.config.AuthConfig.removeSession = cases
  AuthConfig _ _ _ _ _ _ _ _ _ _ removeSession _ -> removeSession

oauth2.config.AuthConfig.removeSession.modify :
  ((session ->{g, Route} ()) ->{h1} session ->{g, h, Route} ())
  -> AuthConfig g idToken session
  ->{h1} AuthConfig {h, g} idToken session
oauth2.config.AuthConfig.removeSession.modify f = cases
  AuthConfig
    uriFromPath
    kickoffOAuthLoginPath
    loginPagePath
    logoutPagePath
    redirectHandlerPath
    oauth2Client
    oauth2Scopes
    successCallback
    validateSession
    saveSession
    removeSession
    useSecureCookies ->
    AuthConfig
      uriFromPath
      kickoffOAuthLoginPath
      loginPagePath
      logoutPagePath
      redirectHandlerPath
      oauth2Client
      oauth2Scopes
      successCallback
      validateSession
      saveSession
      (f removeSession)
      useSecureCookies

oauth2.config.AuthConfig.removeSession.set :
  (session ->{g, h, Route} ())
  -> AuthConfig g idToken session
  -> AuthConfig {h, g} idToken session
oauth2.config.AuthConfig.removeSession.set removeSession1 = cases
  AuthConfig
    uriFromPath
    kickoffOAuthLoginPath
    loginPagePath
    logoutPagePath
    redirectHandlerPath
    oauth2Client
    oauth2Scopes
    successCallback
    validateSession
    saveSession
    _
    useSecureCookies ->
    AuthConfig
      uriFromPath
      kickoffOAuthLoginPath
      loginPagePath
      logoutPagePath
      redirectHandlerPath
      oauth2Client
      oauth2Scopes
      successCallback
      validateSession
      saveSession
      removeSession1
      useSecureCookies

oauth2.config.AuthConfig.saveSession :
  AuthConfig g idToken session -> session ->{g, Route} ()
oauth2.config.AuthConfig.saveSession = cases
  AuthConfig _ _ _ _ _ _ _ _ _ saveSession _ _ -> saveSession

oauth2.config.AuthConfig.saveSession.modify :
  ((session ->{g, Route} ()) ->{h1} session ->{g, h, Route} ())
  -> AuthConfig g idToken session
  ->{h1} AuthConfig {h, g} idToken session
oauth2.config.AuthConfig.saveSession.modify f = cases
  AuthConfig
    uriFromPath
    kickoffOAuthLoginPath
    loginPagePath
    logoutPagePath
    redirectHandlerPath
    oauth2Client
    oauth2Scopes
    successCallback
    validateSession
    saveSession
    removeSession
    useSecureCookies ->
    AuthConfig
      uriFromPath
      kickoffOAuthLoginPath
      loginPagePath
      logoutPagePath
      redirectHandlerPath
      oauth2Client
      oauth2Scopes
      successCallback
      validateSession
      (f saveSession)
      removeSession
      useSecureCookies

oauth2.config.AuthConfig.saveSession.set :
  (session ->{g, h, Route} ())
  -> AuthConfig g idToken session
  -> AuthConfig {h, g} idToken session
oauth2.config.AuthConfig.saveSession.set saveSession1 = cases
  AuthConfig
    uriFromPath
    kickoffOAuthLoginPath
    loginPagePath
    logoutPagePath
    redirectHandlerPath
    oauth2Client
    oauth2Scopes
    successCallback
    validateSession
    _
    removeSession
    useSecureCookies ->
    AuthConfig
      uriFromPath
      kickoffOAuthLoginPath
      loginPagePath
      logoutPagePath
      redirectHandlerPath
      oauth2Client
      oauth2Scopes
      successCallback
      validateSession
      saveSession1
      removeSession
      useSecureCookies

oauth2.config.AuthConfig.successCallback :
  AuthConfig g idToken session
  -> TokenResponse idToken
  ->{g, Route, Exception} session
oauth2.config.AuthConfig.successCallback = cases
  AuthConfig _ _ _ _ _ _ _ successCallback _ _ _ _ -> successCallback

oauth2.config.AuthConfig.successCallback.modify :
  ((TokenResponse idToken ->{g, Route, Exception} t)
  ->{h1} TokenResponse idToken
  ->{g, h, Route, Exception} t)
  -> AuthConfig g idToken t
  ->{h1} AuthConfig {h, g} idToken t
oauth2.config.AuthConfig.successCallback.modify f = cases
  AuthConfig
    uriFromPath
    kickoffOAuthLoginPath
    loginPagePath
    logoutPagePath
    redirectHandlerPath
    oauth2Client
    oauth2Scopes
    successCallback
    validateSession
    saveSession
    removeSession
    useSecureCookies ->
    AuthConfig
      uriFromPath
      kickoffOAuthLoginPath
      loginPagePath
      logoutPagePath
      redirectHandlerPath
      oauth2Client
      oauth2Scopes
      (f successCallback)
      validateSession
      saveSession
      removeSession
      useSecureCookies

oauth2.config.AuthConfig.successCallback.set :
  (TokenResponse idToken ->{g, h, Route, Exception} t)
  -> AuthConfig g idToken t
  -> AuthConfig {h, g} idToken t
oauth2.config.AuthConfig.successCallback.set successCallback1 = cases
  AuthConfig
    uriFromPath
    kickoffOAuthLoginPath
    loginPagePath
    logoutPagePath
    redirectHandlerPath
    oauth2Client
    oauth2Scopes
    _
    validateSession
    saveSession
    removeSession
    useSecureCookies ->
    AuthConfig
      uriFromPath
      kickoffOAuthLoginPath
      loginPagePath
      logoutPagePath
      redirectHandlerPath
      oauth2Client
      oauth2Scopes
      successCallback1
      validateSession
      saveSession
      removeSession
      useSecureCookies

oauth2.config.AuthConfig.uriFromPath :
  AuthConfig g idToken session -> Path ->{Route, Exception} URI
oauth2.config.AuthConfig.uriFromPath = cases
  AuthConfig uriFromPath _ _ _ _ _ _ _ _ _ _ _ -> uriFromPath

oauth2.config.AuthConfig.uriFromPath.modify :
  ((Path ->{Route, Exception} URI) ->{h1} Path ->{Route, Exception} URI)
  -> AuthConfig g idToken session
  ->{h1} AuthConfig {h, g} idToken session
oauth2.config.AuthConfig.uriFromPath.modify f = cases
  AuthConfig
    uriFromPath
    kickoffOAuthLoginPath
    loginPagePath
    logoutPagePath
    redirectHandlerPath
    oauth2Client
    oauth2Scopes
    successCallback
    validateSession
    saveSession
    removeSession
    useSecureCookies ->
    AuthConfig
      (f uriFromPath)
      kickoffOAuthLoginPath
      loginPagePath
      logoutPagePath
      redirectHandlerPath
      oauth2Client
      oauth2Scopes
      successCallback
      validateSession
      saveSession
      removeSession
      useSecureCookies

oauth2.config.AuthConfig.uriFromPath.set :
  (Path ->{Route, Exception} URI)
  -> AuthConfig g idToken session
  -> AuthConfig {h, g} idToken session
oauth2.config.AuthConfig.uriFromPath.set uriFromPath1 = cases
  AuthConfig
    _
    kickoffOAuthLoginPath
    loginPagePath
    logoutPagePath
    redirectHandlerPath
    oauth2Client
    oauth2Scopes
    successCallback
    validateSession
    saveSession
    removeSession
    useSecureCookies ->
    AuthConfig
      uriFromPath1
      kickoffOAuthLoginPath
      loginPagePath
      logoutPagePath
      redirectHandlerPath
      oauth2Client
      oauth2Scopes
      successCallback
      validateSession
      saveSession
      removeSession
      useSecureCookies

oauth2.config.AuthConfig.useSecureCookies :
  AuthConfig g idToken session -> Boolean
oauth2.config.AuthConfig.useSecureCookies = cases
  AuthConfig _ _ _ _ _ _ _ _ _ _ _ useSecureCookies -> useSecureCookies

oauth2.config.AuthConfig.useSecureCookies.modify :
  (Boolean ->{h1} Boolean)
  -> AuthConfig g idToken session
  ->{h1} AuthConfig {h, g} idToken session
oauth2.config.AuthConfig.useSecureCookies.modify f = cases
  AuthConfig
    uriFromPath
    kickoffOAuthLoginPath
    loginPagePath
    logoutPagePath
    redirectHandlerPath
    oauth2Client
    oauth2Scopes
    successCallback
    validateSession
    saveSession
    removeSession
    useSecureCookies ->
    AuthConfig
      uriFromPath
      kickoffOAuthLoginPath
      loginPagePath
      logoutPagePath
      redirectHandlerPath
      oauth2Client
      oauth2Scopes
      successCallback
      validateSession
      saveSession
      removeSession
      (f useSecureCookies)

oauth2.config.AuthConfig.useSecureCookies.set :
  Boolean -> AuthConfig g idToken session -> AuthConfig {h, g} idToken session
oauth2.config.AuthConfig.useSecureCookies.set useSecureCookies1 = cases
  AuthConfig
    uriFromPath
    kickoffOAuthLoginPath
    loginPagePath
    logoutPagePath
    redirectHandlerPath
    oauth2Client
    oauth2Scopes
    successCallback
    validateSession
    saveSession
    removeSession
    _ ->
    AuthConfig
      uriFromPath
      kickoffOAuthLoginPath
      loginPagePath
      logoutPagePath
      redirectHandlerPath
      oauth2Client
      oauth2Scopes
      successCallback
      validateSession
      saveSession
      removeSession
      useSecureCookies1

oauth2.config.AuthConfig.validateSession :
  AuthConfig g idToken session -> '{g, Route} Optional session
oauth2.config.AuthConfig.validateSession = cases
  AuthConfig _ _ _ _ _ _ _ _ validateSession _ _ _ -> validateSession

oauth2.config.AuthConfig.validateSession.modify :
  ('{g, Route} Optional session ->{h1} '{g, h, Route} Optional session)
  -> AuthConfig g idToken session
  ->{h1} AuthConfig {h, g} idToken session
oauth2.config.AuthConfig.validateSession.modify f = cases
  AuthConfig
    uriFromPath
    kickoffOAuthLoginPath
    loginPagePath
    logoutPagePath
    redirectHandlerPath
    oauth2Client
    oauth2Scopes
    successCallback
    validateSession
    saveSession
    removeSession
    useSecureCookies ->
    AuthConfig
      uriFromPath
      kickoffOAuthLoginPath
      loginPagePath
      logoutPagePath
      redirectHandlerPath
      oauth2Client
      oauth2Scopes
      successCallback
      (f validateSession)
      saveSession
      removeSession
      useSecureCookies

oauth2.config.AuthConfig.validateSession.set :
  '{g, h, Route} Optional session
  -> AuthConfig g idToken session
  -> AuthConfig {h, g} idToken session
oauth2.config.AuthConfig.validateSession.set validateSession1 = cases
  AuthConfig
    uriFromPath
    kickoffOAuthLoginPath
    loginPagePath
    logoutPagePath
    redirectHandlerPath
    oauth2Client
    oauth2Scopes
    successCallback
    _
    saveSession
    removeSession
    useSecureCookies ->
    AuthConfig
      uriFromPath
      kickoffOAuthLoginPath
      loginPagePath
      logoutPagePath
      redirectHandlerPath
      oauth2Client
      oauth2Scopes
      successCallback
      validateSession1
      saveSession
      removeSession
      useSecureCookies

oauth2.config.defaultCloud :
  HMACKey
  -> Oauth2Client idToken
  -> Optional Text
  -> (TokenResponse idToken ->{g, Route, Exception} session)
  -> '{g, Decoder} session
  -> (session ->{g} Json)
  -> Boolean
  -> AuthConfig {Exception, g} idToken session
oauth2.config.defaultCloud
  hmacKey
  oauthClient
  oauth2Scopes
  onSuccess
  jsonDecoder
  jsonEncoder
  useSecureCookies =
  use Duration *
  use Optional None
  httpOnlyCookies = true
  loginPagePath = Path ["login"]
  logoutPagePath = Path ["logout"]
  redirectHandlerPath = Path ["oauth", "redirect"]
  _ =
    {{ For the default config, the login path just kicks off the oauth flow. }}
  oauthKickoffPath = loginPagePath
  sessionCookieName = "session"
  sessionTTL = +30 * Duration.day
  validateSession : '{g, Route} Optional session
  validateSession =
    Abort.toOptional do
      abortOnException do
        bundle : Text
        bundle = getCookie sessionCookieName |> Optional.toAbort
        verifyBundle hmacKey bundle
          |> Optional.toAbort
          |> fromUtf8
          |> tryRun jsonDecoder
          |> Either.toAbort
  saveSession : session ->{g, Route, Exception} ()
  saveSession session =
    sessionBytes = jsonEncoder session |> Json.toText |> Text.toUtf8
    signedSession = signBundle hmacKey sessionBytes
    _ = {{ Default to secure unless we're running on http. }}
    sessionCookie =
      Cookie
        sessionCookieName
        signedSession
        None
        (Some sessionTTL)
        None
        (Some (Path []))
        useSecureCookies
        httpOnlyCookies
        (Some Lax)
    setCookie sessionCookie
  removeSession _sess =
    expiredCookie =
      Cookie
        sessionCookieName
        ""
        None
        (Some Duration.zero)
        None
        (Some (Path []))
        useSecureCookies
        httpOnlyCookies
        (Some Lax)
    setCookie expiredCookie
  AuthConfig
    pathToURIOnCloud
    oauthKickoffPath
    loginPagePath
    logoutPagePath
    redirectHandlerPath
    oauthClient
    oauth2Scopes
    onSuccess
    validateSession
    saveSession
    removeSession
    useSecureCookies

oauth2.config.defaultWeb :
  HMACKey
  -> URI
  -> Oauth2Client idToken
  -> Optional Text
  -> (TokenResponse idToken ->{g, Route, Exception} session)
  -> '{g, Decoder} session
  -> (session ->{g} Json)
  -> Boolean
  -> AuthConfig {Exception, g} idToken session
oauth2.config.defaultWeb
  hmacKey
  baseURI
  oauthClient
  oauth2Scopes
  onSuccess
  jsonDecoder
  jsonEncoder
  useSecureCookies =
  use Duration *
  use Optional None
  use Path ++
  loginPagePath = Path ["login"]
  logoutPagePath = Path ["logout"]
  redirectHandlerPath = Path ["oauth", "redirect"]
  httpOnlyCookies = true
  _ =
    {{ For the default config, the login path just kicks off the oauth flow. }}
  oauthKickoffPath = loginPagePath
  sessionCookieName = "session"
  sessionTTL = +30 * Duration.day
  validateSession : '{g, Route} Optional session
  validateSession =
    Abort.toOptional do
      abortOnException do
        bundle : Text
        bundle = getCookie sessionCookieName |> Optional.toAbort
        verifyBundle hmacKey bundle
          |> Optional.toAbort
          |> fromUtf8
          |> tryRun jsonDecoder
          |> Either.toAbort
  saveSession : session ->{g, Route, Exception} ()
  saveSession session =
    sessionBytes = jsonEncoder session |> Json.toText |> Text.toUtf8
    signedSession = signBundle hmacKey sessionBytes
    _ = {{ Default to secure unless we're running on http. }}
    sessionCookie =
      Cookie
        sessionCookieName
        signedSession
        None
        (Some sessionTTL)
        None
        (Some (Path []))
        useSecureCookies
        httpOnlyCookies
        (Some Lax)
    setCookie sessionCookie
  removeSession _sess =
    expiredCookie =
      Cookie
        sessionCookieName
        ""
        None
        (Some Duration.zero)
        None
        (Some (Path []))
        useSecureCookies
        httpOnlyCookies
        (Some Lax)
    setCookie expiredCookie
  pathToURI path = baseURI |> URI.path.modify (rootPath -> rootPath ++ path)
  AuthConfig
    pathToURI
    oauthKickoffPath
    loginPagePath
    logoutPagePath
    redirectHandlerPath
    oauthClient
    oauth2Scopes
    onSuccess
    validateSession
    saveSession
    removeSession
    useSecureCookies

oauth2.example.appRoutes : '{Route, Auth UserId} ()
oauth2.example.appRoutes =
  use Route <|>
  use Text ++ toUtf8
  use respond ok
  publicRoute : '{Route, Auth UserId} ()
  publicRoute = do
    noCapture GET Parser.root
    match getSession with
      Optional.None     -> unauthorized (toUtf8 "Hello mysterious stranger!")
      Some (UserId uid) -> ok (toUtf8 ("Hello user " ++ uid ++ "!"))
  privateRoute : '{Route, Auth UserId} ()
  privateRoute = do
    noCapture GET (s "private")
    let
      (UserId uid) = requireSession
      ok (toUtf8 ("This is your super secret page " ++ uid ++ "!"))
  publicRoute <|> privateRoute

oauth2.example.httpServer.doc : Doc
oauth2.example.httpServer.doc =
  {{
  An example http server which uses the {type Auth} ability to handle user
  authentication.
  }}

oauth2.example.main : '{IO, Exception} ()
oauth2.example.main =
  do
    use Optional None
    _ =
      "Load our oauth client information from the environment and build a google oauth client."
    googleClientId = getEnv "GOOGLE_TEST_CLIENT_ID"
    googleClientSecret = getEnv "GOOGLE_TEST_CLIENT_SECRET"
    oauthClient =
      google (ClientId googleClientId) (ClientSecret googleClientSecret)
    additionalScopes = None
    _ =
      """
      The URI where our server will be running. It is used for generating the Oauth2
      Redirect URI
      """
    baseURI = URI.parse "http://localhost:8080"
    _ =
      """
      The secret key used to sign session cookies in our app. Make sure to change
      this to your own cryptographically secure secret of a sufficient length.
      """
    hmacKey = HMACKey (getEnv "HMAC_KEY" |> Text.toUtf8)
    _ =
      """
      This callback will be called when the user successfully completes an
      OAuth flow. You can use the tokens provided by the Identity Provider to
      fetch user credentials and generate your user session, and/or save the user
      in your storage layer.

      In this example, we use the OpenID Connect ID Token provided by google, and
      decode it to get the google user ID, which we then use as our session. In
      your app you'll likely want to create a user in your own app, or take
      measures to distinguish between users logging in via different identity
      providers.

      Note that whatever this function returns will be stored in the user's browser cookies.
      It is signed, but not encrypted, so avoid any sensitive information here.
      """
    successCallback : TokenResponse IdToken ->{Exception, Http} UserId
    successCallback tokenResponse =
      (IdToken jwtText) = idToken tokenResponse
      jwt = jwt_0_0_1.decode jwtText
      match Jwt.sub jwt with
        None     -> raiseGeneric "No sub in JWT" jwt
        Some sub -> UserId sub
    _ =
      "We need to define serializers for our session type since it will be stored as text in a cookie."
    encodeUserId : UserId -> Json
    encodeUserId = cases UserId uid -> Json.text uid
    decodeUserId : '{Decoder} UserId
    decodeUserId = do UserId Decoder.text()
    _ =
      """
      If you're running your app on localhost for testing you may wish to disable secure cookies so that the app works without https.
      When running in production, always set `useSecureCookies = true`
      """
    useSecureCookies = true
    authConfig : AuthConfig {Http, Exception} IdToken UserId
    authConfig =
      defaultWeb
        hmacKey
        baseURI
        oauthClient
        additionalScopes
        successCallback
        decodeUserId
        encodeUserId
        useSecureCookies
    stop =
      serveSimple
        (appRoutes
          |> delay (oauth2.handler authConfig)
          |> delay Http.run
          |> delay Random.run)
        8080
    printLine "Starting server on http://localhost:8080"
    base.abilities.forever do sleep Duration.day
    stop()

oauth2.handler :
  AuthConfig g idToken session
  -> '{h, Route, Auth session} ()
  ->{g, h, Route, Exception, Http, Random} ()
oauth2.handler config action =
  use Optional None
  use Route <|>
  continueToParam = "continueTo"
  stateCookieName = "oauth_state"
  redirectURI = uriFromPath config (redirectHandlerPath config)
  buildLoginURI : Optional URI -> URI
  buildLoginURI = cases
    None -> uriFromPath config (loginPagePath config)
    Some originalUri ->
      uriFromPath config (loginPagePath config)
        |> withQuery
          (fromQuery
            (Query.empty
              & ( continueToParam
              , URI.path originalUri |> uriFromPath config |> URI.toText
              )))
  logoutRoute : '{g, Route, Exception, Auth session} ()
  logoutRoute = do
    noCapture GET (pathToUriParser <| logoutPagePath config)
    match getSession with
      None         -> redirect (uriFromPath config (Path []))
      Some session ->
        removeSession config session
        redirect (uriFromPath config (Path []))
  oauthKickoffRoute =
    do
      use Text ++
      noCapture GET (pathToUriParser <| kickoffOAuthLoginPath config)
      continueTo = match queryParameter continueToParam with
        [continueURIText] -> parseOptional continueURIText
        _                 -> None
      scopes = match oauth2Scopes config with
        None                  -> "openid"
        Some additionalScopes -> "openid " ++ additionalScopes
      kickoffOAuthRoute
        stateCookieName
        (AuthConfig.useSecureCookies config)
        continueTo
        (Scope scopes)
        redirectURI
        (oauth2Client config)
  redirectHandlerRoute : '{g, Route, Exception, Http} ()
  redirectHandlerRoute = do
    noCapture GET (pathToUriParser <| redirectHandlerPath config)
    match internal.redirectHandlerRoute stateCookieName config with
      Left err -> respond.badRequest (Text.toUtf8 err)
      Right () -> ()
  maybeSession = validateSession config ()
  go : Request {Auth session} () -> ()
  go = cases
    { r }                        -> r
    { getSession -> resume }     -> handle resume maybeSession with go
    { requireSession -> resume } ->
      match maybeSession with
        None         ->
          _ = "We purposefully don't resume the caller's handler here."
          loginURI = buildLoginURI (Some request.uri())
          redirect loginURI
        Some session -> handle resume session with go
  appWithoutAuthAbility : '{g, h, Route, Exception} ()
  appWithoutAuthAbility = do handle (<|>) logoutRoute action () with go
  (<|>) (oauthKickoffRoute <|> redirectHandlerRoute) appWithoutAuthAbility ()

oauth2.handler.doc : Doc
oauth2.handler.doc =
  use oauth2 handler
  {{
  This handler provides a batteries-included authentication system for web
  applications in Unison using external OAuth2 Identity Providers.

  When you are ready to run your application you can handle the {type Auth}
  ability using the {{ docLink (docEmbedTermLink do handler) }} handler. By
  default this handler will add the following routes to your application:

  * `/login`: kicks off a login flow with the provided identity provider.
  * `/logout`: logs the user out of the application.
  * `/oauth/redirect`: which is an oauth2 callback for completing the oauth2
    flow

  # Usage

    Here's an example of how we can use the {type Auth} ability in a simple web
    application. This app defines two routes:

    * `/` which is accessible to anyone, but will greet the user by their user
      ID if they are logged in.
    * `/private` which is only accessible to authenticated users, it will send
      unauthenticated users through the login flow.

    {{ docSource [docSourceElement (docEmbedTermLink do appRoutes) []] }}

    In order to handle the {type Auth} ability, we need to provide the {{
    docLink (docEmbedTermLink do handler) }} with an {type AuthConfig}. You can
    construct one manually, but I recommend starting with
    {{ docLink (docEmbedTermLink do defaultCloud) }}. Here's an example
    application that grabs some secrets from environment variables and
    configures authentication with a Google oauth2 client.

    {{
    docSource [docSourceElement (docEmbedTermLink do oauth2.example.main) []]
    }}

  # Picking an OAuth Identity provider

    At the moment the library requires providing a single specific OAuth2
    client for the identity provider you want to use, but will likely be
    expanded to support multiple providers in the future. If this is a feature
    you need, ping us in the Unison Discord and let us know!

    There are several OAuth2 Client builders available in the
    [@alvaroc1/oauth2](https://share.unison-lang.org/@alvaroc1/oauth2/code/releases/0.0.4/latest/namespaces/Oauth2Client)
    library to get started with. See each provider's documentation to learn how
    to register your app with them.

  # Customizing the Auth Handler

    You're certainly free to provide your own implementation of a handler for
    the {type Auth} ability, however a degree of customization is available via
    the {type AuthConfig} itself:

        @source{type AuthConfig}

    **Fields:**

    {{ AuthConfig.doc }}

  # TODO

    * Handle errors on redirect route
    * Allow multiple identity providers
    * Allow customizing default landing page
    * Implement /logout
  }}

oauth2.internal.Base64UrlUnpadded.decodeText :
  Base64UrlUnpadded Text ->{Exception} Optional Text
oauth2.internal.Base64UrlUnpadded.decodeText = cases
  Base64UrlUnpadded txt ->
    Text.toUtf8 txt
      |> fromBase64UrlUnpadded
      |> Either.toOptional
      |> Optional.map fromUtf8

oauth2.internal.Base64UrlUnpadded.encodeText :
  Text ->{Exception} Base64UrlUnpadded Text
oauth2.internal.Base64UrlUnpadded.encodeText txt =
  txt |> Text.toUtf8 |> toBase64UrlUnpadded |> fromUtf8 |> Base64UrlUnpadded

oauth2.internal.decodeState :
  Base64UrlUnpadded Text ->{Exception} Optional internal.State
oauth2.internal.decodeState encodedState =
  toOptional! do
    encodedState
      |> decodeText
      |> Optional.toAbort
      |> Text.split ?|
      |> (cases
           ["", stateId] -> internal.State.State Optional.None stateId
           [continueToText, stateId] ->
             internal.State.State (parseOptional continueToText) stateId
           _ -> abort "Invalid state")

oauth2.internal.encodeState :
  internal.State ->{Exception} Base64UrlUnpadded Text
oauth2.internal.encodeState = cases
  internal.State.State continueTo stateId ->
    use Text ++
    urlText = Optional.fold (do "") URI.toText continueTo
    urlText ++ "|" ++ stateId |> encodeText

oauth2.internal.newState : Optional URI ->{Random} internal.State
oauth2.internal.newState continueTo =
  internal.State.State continueTo v4.new.asText()

oauth2.internal.parseAuthParams : '{Route, Throw Text} (Text, Text)
oauth2.internal.parseAuthParams = do
  use Text ++
  expectOneParam name = match queryParameter name with
    []      -> throw ("Missing required " ++ name ++ " parameter")
    [value] -> value
    _       -> throw ("Multiple " ++ name ++ " parameters")
  code = expectOneParam "code"
  state = expectOneParam "state"
  (code, state)

oauth2.internal.parseAuthParams.doc : Doc
oauth2.internal.parseAuthParams.doc =
  {{ Parses the code and state from the query parameters. }}

oauth2.internal.pathToURIOnCloud : Path ->{Route, Exception} URI
oauth2.internal.pathToURIOnCloud path =
  match (header "Unison-Cloud-Base-Path", header "Host") with
    ([pathText], [hostText]) ->
      match catch do Path.fromText pathText with
        Right cloudPath ->
          match catch do
            URI.parse ("https://" Text.++ hostText)
              |> URI.path.modify (_ -> cloudPath Path.++ path) with
            Right uri -> uri
            Left _ ->
              raiseInternalServerError
                "Invalid Host or Unison-Cloud-Base-Path header"
                (hostText, pathText)
        Left _ ->
          raiseInternalServerError
            "Invalid Host or Unison-Cloud-Base-Path header"
            (hostText, pathText)
    headers ->
      raiseInternalServerError
        "Invalid Host or Unison-Cloud-Base-Path header" headers

oauth2.internal.State.continueTo : internal.State -> Optional URI
oauth2.internal.State.continueTo = cases
  internal.State.State continueTo _ -> continueTo

oauth2.internal.State.continueTo.modify :
  (Optional URI ->{g} Optional URI) -> internal.State ->{g} internal.State
oauth2.internal.State.continueTo.modify f = cases
  internal.State.State continueTo stateId ->
    internal.State.State (f continueTo) stateId

oauth2.internal.State.continueTo.set :
  Optional URI -> internal.State -> internal.State
oauth2.internal.State.continueTo.set continueTo1 = cases
  internal.State.State _ stateId -> internal.State.State continueTo1 stateId

oauth2.internal.State.stateId : internal.State -> Text
oauth2.internal.State.stateId = cases internal.State.State _ stateId -> stateId

oauth2.internal.State.stateId.modify :
  (Text ->{g} Text) -> internal.State ->{g} internal.State
oauth2.internal.State.stateId.modify f = cases
  internal.State.State continueTo stateId ->
    internal.State.State continueTo (f stateId)

oauth2.internal.State.stateId.set : Text -> internal.State -> internal.State
oauth2.internal.State.stateId.set stateId1 = cases
  internal.State.State continueTo _ -> internal.State.State continueTo stateId1

oauth2.README : Doc
oauth2.README =
  {{
  # OAuth2 Auth Handler

    {{ oauth2.handler.doc }}
  }}

oauth2.requireSessionOrSkip : '{Route, Auth session} session
oauth2.requireSessionOrSkip = do match getSession with
  Optional.None -> Route.skip <| failure "Unauthorized" ()
  Some session  -> session

oauth2.requireSessionOrSkip.doc : Doc
oauth2.requireSessionOrSkip.doc =
  {{ Get the user's session if they're logged in, otherwise skip the route. }}

oauth2.routes.internal.BadRequest.toBytes : internal.BadRequest -> Bytes
oauth2.routes.internal.BadRequest.toBytes = cases
  BadRequest message -> message |> Text.toUtf8

oauth2.routes.internal.kickoffOAuthRoute :
  Text
  -> Boolean
  -> Optional URI
  -> oauth2_main.Scope
  -> URI
  -> Oauth2Client t
  ->{Route, Exception, Random} ()
oauth2.routes.internal.kickoffOAuthRoute
  stateCookieName useSecureCookies continueTo scope redirectURI oauth2Client =
  use Duration *
  use Optional None
  state = newState continueTo
  httpOnlyCookie = true
  let
    (Base64UrlUnpadded encodedState) = encodeState state
    stateCookie =
      Cookie
        stateCookieName
        encodedState
        None
        (Some (+5 * Duration.minute))
        None
        None
        useSecureCookies
        httpOnlyCookie
        None
    setCookie stateCookie
    authURL =
      buildAuthorizationUrl
        scope (oauth2_main.State.State encodedState) redirectURI oauth2Client
    redirect authURL

oauth2.routes.internal.kickoffOAuthRoute.doc : Doc
oauth2.routes.internal.kickoffOAuthRoute.doc =
  {{ Initiates a login with provided OAuth2 client. }}

oauth2.routes.internal.redirectHandlerRoute :
  Text
  -> AuthConfig g idToken session
  ->{g, Route, Exception, Http} Either Text ()
oauth2.routes.internal.redirectHandlerRoute stateCookieName config =
  use Optional None
  use Text !=
  oauthClient = oauth2Client config
  redirectURI = uriFromPath config (redirectHandlerPath config)
  toEither do
    (code, state) = parseAuthParams()
    match getCookie stateCookieName with
      None -> throw "No state cookie found"
      Some cookieState ->
        if cookieState != state then throw "State vs cookie mismatch" else ()
    tokenResponse =
      oauth2.requestAccessToken
        (AuthorizationCode code) redirectURI oauthClient
    session = successCallback config tokenResponse
    saveSession config session
    match decodeState (Base64UrlUnpadded state) with
      Some (internal.State.State continueTo _) ->
        match continueTo with
          Some continueTo -> redirect continueTo
          None            -> redirect (uriFromPath config (Path []))
      None                                     -> throw "Invalid state"

oauth2.routes.internal.redirectHandlerRoute.doc : Doc
oauth2.routes.internal.redirectHandlerRoute.doc =
  {{ Handles the OAuth2 callback, exchanging the code for a token. }}

README : Doc
README =
  {{
  # Auth

    ## The Auth Ability

       You can access the session of the currently authenticated user with the
       {type Auth} ability.

           @source{type Auth}

       {{ Auth.doc }}

    ## Auth Handlers

       There are a few different ways to handle the {type Auth} ability.

       * {{ docLink (docEmbedTermLink do oauth2.handler) }} (RECOMMENDED): A
         batteries-included oauth2 authentication solution. See {{
         docLink (docEmbedTermLink do oauth2.README) }} for more information.
       * {{ docLink (docEmbedTermLink do anonymous.handler) }}: A dead-simple
         auth system suitable for toy apps or apps with ephemeral user data.
         See {{ docLink (docEmbedTermLink do anonymous.README) }} for more
         information.
  }}

ReleaseNotes : Doc
ReleaseNotes =
  {{
  Adds a `useSecureCookies` argument when building an {type AuthConfig} using
  either {{ docLink (docEmbedTermLink do defaultWeb) }} or
  {{ docLink (docEmbedTermLink do defaultCloud) }}. As well as to
  {type anonymous.Config}.

  This allows you to disable the `secure` field on the cookies used by the auth
  library, which can be useful when testing on localhost where `https` may not
  be supported.

  When running in production, always pass `true` as the `useSecureCookies`
  value.
  }}

up.oauth2.requestAccessToken :
  AuthorizationCode
  -> URI
  -> Oauth2Client a
  ->{Exception, Http} TokenResponse a
up.oauth2.requestAccessToken authorizationCode redirectUri = cases
  Oauth2Client
    (ClientId clientId)
    (ClientSecret clientSecret)
    _
    tokenEndpoint
    responseDecoder ->
    (AuthorizationCode code) = authorizationCode
    use HttpRequest addHeader
    data =
      Query.empty
        |> addParam "client_id" clientId
        |> addParam "client_secret" clientSecret
        |> addParam "code" code
        |> addParam "grant_type" "authorization_code"
        |> addParam "redirect_uri" (URI.toText redirectUri)
        |> formEncoded
    response =
      HttpRequest.post tokenEndpoint data
        |> addHeader "Content-Type" "application/x-www-form-urlencoded"
        |> addHeader "Accept" "application/json"
        |> request
    bodyText = HttpResponse.body response |> Body.toBytes |> fromUtf8
    decoded =
      bodyText
        |> json.Decoder.run (TokenResponse.jsonDecoder responseDecoder)
        |> Either.fold Exception.raise (a -> a)
    decoded

utils.handleBadRequest : '{g, Throw internal.BadRequest} () -> '{g, Route} ()
utils.handleBadRequest route =
  do catchWith (BadRequest.toBytes >> respond.badRequest) route

utils.hmac.HMACKey.bytes : HMACKey -> Bytes
utils.hmac.HMACKey.bytes = cases HMACKey bytes -> bytes

utils.hmac.signBundle : HMACKey -> Bytes ->{Exception} Text
utils.hmac.signBundle key payload =
  use Text ++
  digest = hmacBytes Sha3_256 (HMACKey.bytes key) payload
  digestB64 = toBase64UrlUnpadded digest
  payloadB64 = payload |> toBase64UrlUnpadded
  fromUtf8 payloadB64 ++ "." ++ fromUtf8 digestB64

utils.hmac.verify : HMACKey -> Bytes -> Bytes -> Boolean
utils.hmac.verify key userId digest =
  expected = hmacBytes Sha3_256 (HMACKey.bytes key) userId
  constantTimeEqual expected digest

utils.hmac.verifyBundle : HMACKey -> Text -> Optional Bytes
utils.hmac.verifyBundle key signed =
  toOptional!
    <| (do
      use Either toAbort
      use Text toUtf8
      parts = signed |> Text.split ?.
      match parts with
        [payload, digest] ->
          payloadBytes = toAbort <| fromBase64UrlUnpadded (toUtf8 payload)
          digestBytes = toAbort <| fromBase64UrlUnpadded (toUtf8 digest)
          if utils.hmac.verify key payloadBytes digestBytes then payloadBytes
          else abort
        _ -> abort)

utils.http.redirect : URI ->{Route} ()
utils.http.redirect uri =
  status.text (Status 302 "Found") "Redirected"
  headers.add "Location" (URI.toText uri)

utils.pathToUriParser : Path -> Parser a a
utils.pathToUriParser = cases
  Path endpointSegments ->
    endpointSegments
      |> List.foldLeft (acc segment -> acc Parser./ s segment) top
